# Bird_Tracker – README

Мінімальний пайплайн для офлайн-трекінгу пташки з компенсацією глобального руху (GMC), класифікацією кадрів за якістю, квадратичною інтерполяцією «поганих» кадрів, трекінгом на реконструйованій термографії та проєкцією прицілу на оригінал.

---

## Структура проєкту

```
Lesson10/
└─ Bird_Tracker/
   ├─ source/                 # вхідні відео/кадри (оригінал)
   │   └─ hawk5.mp4
   ├─ data/                   # проміжні артефакти (відео + JSON)
   ├─ result/                 # фінальні результати (те, що показуємо)
   ├─ config.json             # налаштування пайплайну
   ├─ main.py                 # керує запуском етапів (із пропусками, якщо файли існують)
   ├─ step01_motion.py        # GMC + термографія
   ├─ step02_quality.py       # класифікація good/bad
   ├─ step03_interpolate.py   # квадратична інтерполяція bad-блоків
   ├─ step04_track.py         # трекінг (CSRT/KCF) по грейскейл-термографії
   ├─ step05_overlay.py       # проєкція треку на оригінальне відео
   └─ utils.py                # утиліти (I/O, ROI, відеозапис, геометрія)
```

---

## Порядок роботи (UX flow)

1. **Етап 0 – ROI на оригінальному першому кадрі.** Зберігається в `data/00_roi.json`. Якщо файл існує — пропускається.
2. **Етап 1 – Thermography + GMC.** Пише `data/1.thermo.mp4` і `data/1.transforms.json`. Якщо існує — пропускається.
3. **Етап 2 – Класифікація good/bad.** Пише `data/2.classification.json` (+ опц. `data/2.classified.mp4`). Якщо існує — пропускається.
4. **Етап 3 – Реконструкція (квадратична інтерполяція).** Пише `data/3.thermo_restored.mp4`. Якщо існує — пропускається.
5. **Етап 4 – Трекінг на грейскейл-термографії.** Пише `data/4.track.json`. Якщо існує — пропускається.
6. **Етап 5 – Проєкція на оригінал.** Пише `result/overlay_tracked.mp4`.

На кожному етапі виводиться прогрес-бар у терміналі. Всі шляхи відносні.

---

## Конфігурація: `config.json`

Нижче — опис кожного параметра, тип значення, дефолт і поради.

### Корінь

* **`source_video`** (string) — шлях до вхідного відео відносно `Bird_Tracker/`.

  * *Приклад:* `"source/hawk5.mp4"`.

### `io`

* **`codec`** (string) — fourcc-кодек для вихідних відео. Мінімально сумісний — `"mp4v"`.
* **`fps`** (number) — FPS для запису. Якщо `0` або не задано, береться FPS з джерела.

### `motion` (Етап 1 – GMC + термографія)

* **`gmc_model`** (string) — модель глобальної компенсації: `"homography"` або `"affine"`.

  * *Коли обирати:* `homography` для сцени з перспективними зсувами; `affine` — для майже пласких рухів.
* **`feature`** (string) — детектор/дескриптор: `"ORB"` (швидкий, надійний) або `"AKAZE"` (стабільніший на текстурах, повільніший).
* **`max_features`** (int, 500–5000) — верхня межа ключових точок; більше — надійніша оцінка `H`, але повільніше.
* **`ransac_reproj_thresh`** (float, ~1.5–5.0) — толерантність RANSAC (пікселі). Менше — точніше, але може «зриватися» на шумних даних.
* **`sensitivity`** (float, 0.7–2.0) — «гамма»-ручка чутливості карти руху:

  * <1.0 — підсилює слабкі рухи (більше «червоного»),
  * > 1.0 — пригнічує дрібний рух (гілки/шум). Добре для пташки на фоні дерев.
* **`motion_threshold`** (0–255) — поріг інтенсивності після нормалізації/гамми, нижче якого пікселі вважаються нерухомими (фарбується темно-синім).

### `classification` (Етап 2 – good/bad)

* **`metric`** (string) — що міряємо на термокадрі:

  * `"variance"` — дисперсія яскравості; висока → більше «випадкового» руху/шуму,
  * `"entropy"` — ентропія гістограми; висока → більш «різнорідний» кадр,
  * `"active_ratio"` — частка пікселів, що перевищили `active_threshold`.
* **`threshold`** (float) — поріг для метрики (див. нижче «Налаштування за симптомами»).
* **`active_threshold`** (int, 0–255) — поріг інтенсивності для метрики `active_ratio`.

### `interpolation` (Етап 3)

* **`mode`** (string) — `"quadratic"` — квадратичне зважування між good-кадрами: кадри ближче до лівої/правої опори сильніше притискаються до відповідного good.

  * Формула ваг: `α=(1−j/K)^2`, `β=(j/K)^2`, де `j` — позиція в прогалині, `K` — довжина прогалини.

### `tracking` (Етап 4)

* **`tracker`** (string) — `"CSRT"` (точність, важче) або `"KCF"` (швидше, простіше). У разі проблем — fallback на MOSSE в коді.
* **`grayscale`** (bool) — історично використовувався; в актуальній реалізації трекер ініціалізується на BGR для сумісності, але поле лишаємо для майбутніх варіантів.

---

## Детальні підлаштування по етапах

### Етап 1 — GMC + термографія

**Мета:** прибрати рух камери, підсвітити локальний рух (пташку).

* Збільш **`max_features`** якщо сцена бідна на ключові точки (рідко знаходиться `H`).
* Якщо проєкція «пливе» або з’являються «желейні» артефакти — збільш **`ransac_reproj_thresh`** до 4–5 або переключись на `affine`.
* Якщо термокарта занадто «гаряча» на фоні: підніми **`sensitivity`** і/або **`motion_threshold`**.
* Якщо пташка губиться (слабкий контраст на термокарті): зменш **`sensitivity`** (0.8–1.0) і **`motion_threshold`**.

### Етап 2 — Класифікація good/bad

**Мета:** відсікти шумні кадри.

* `variance` — стартуй із **`threshold=0.01–0.03`** (нормовано на 255² в коді). Якщо забагато good → підвищуй поріг; якщо забагато bad → знижуй.
* `entropy` — підбирай емпірично; високі значення часто означають «різнобарвний» шум/рух.
* `active_ratio` — поклади **`active_threshold`** ~20–40; `threshold` 0.02–0.15.

### Етап 3 — Інтерполяція

**Мета:** відновити прогалини з мінімумом мерехтіння.

* Для довгих прогалин (K≥3) квадратичні ваги помітно кращі за лінійні: менше «ступенів».
* Якщо прогалини дуже довгі і результат «пливе», спробуй зменшити чутливість на Етапі 1 (щоб менше bad) або розбити відео на ділянки.

### Етап 4 — Трекінг

**Мета:** стабільна траєкторія плямки на реконструйованій термографії.

* Ініціалізація відбувається на **першому `good` кадрі** з класифікації — це критично для старту CSRT/KCF.
* Якщо ініціалізація падає:

  * Збільш ROI на 10–20%,
  * Перемкни `tracker` на `KCF` у `config.json`,
  * Перевір збірку OpenCV (наявність `legacy`/`contrib`).

### Етап 5 — Проєкція

**Мета:** накласти трек на оригінал.

* Проєкція використовує інверсію кумулятивної матриці `C_t`. Якщо рамка «пливе», проблема, ймовірно, в нестабільних `C_t` з Етапу 1 → повернись і підкрути GMC.

---

## Налаштування за симптомами (cheatsheet)

* **Термокарта «палає» скрізь:
* `data/00_roi.json` — ROI з Етапу 0.
* `data/1.thermo.mp4` — термографія (GMC + карта руху).
* `data/1.transforms.json` — список кумулятивних перетворень кадр→референс (C_t).
* `data/2.classification.json` — мітки `good/bad` по кадрах.
* `data/2.classified.mp4` — опційне прев’ю з мітками.
* `data/3.thermo_restored.mp4` — реконструйована термографія (інтерполяція bad-блоків).
* `data/4.track.json` — трек (масив `{frame,x,y,w,h}`).
* `result/overlay_tracked.mp4` — фінал: оверлей прицілу на оригіналі.

Кешування: якщо відповідний файл існує — етап пропускається, наступний читає готовий артефакт.

---

## Запуск

У середовищі з `opencv-python` та `numpy` (опційно `tqdm`):

```
python main.py
```

* При першому запуску з’явиться вікно вибору ROI на першому кадрі оригінального відео.
* Проміжні результати підуть у `data/`, фінал — у `result/`.

---

## Поради з налаштування

* Якщо термографія «надто шумна» → збільшити `motion.sensitivity` і/або `motion.motion_threshold`.
* Якщо забагато кадрів позначаються як `bad` → послабити `classification.threshold` (для вашої метрики).
* Якщо трекер рветься на перешкодах → зменшити ROI або ініціалізувати точніше; перемкнутись на KCF.
* Якщо проєкція рамки «пливе» → перевірити стабільність GMC: `gmc_model`, `ransac_reproj_thresh`, тип фіч.

---

## Відомі обмеження

* Працює з одним об’єктом.
* Без навчання/ML; трекер класичний (CSRT/KCF).
* Усі відео в пайплайні мають сталий розмір і FPS (беремо з джерела).

---

## Усередині кроків (коротко)

* **GMC:** ORB/AKAZE → відповідності → RANSAC → `H` → кумулятивні `C_t` → вирівнювання.
* **Thermo:** |Δ(вирівняні кадри)| → нормалізація → «гамма»-підсилення чутливості → COLORMAP_JET.
* **Quality:** variance/entropy/active_ratio → порогування → мітки.
* **Interpolate:** квадратичні ваги між опорними good → заміна bad-кадрів.
* **Track:** CSRT/KCF по грейскейл-термографії.
* **Overlay:** перетворення bbox назад в оригінальний кадр через `C_t^{-1}` та малювання полігону.
